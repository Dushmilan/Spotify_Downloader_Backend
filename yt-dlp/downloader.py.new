if __name__ == "__main__":
    import sys
    
    if len(sys.argv) < 2:
        print(json.dumps({'success': False, 'error': 'Usage: python downloader.py <url_or_trackname> [artist_name] [output_path] or python downloader.py download <url> <output_path>'}), file=sys.stderr)
        sys.exit(1)
    
    try:
        # Handle the case where arguments may have been split due to spaces in track names or artist names
        # We need to intelligently reconstruct the arguments based on expected patterns
        
        # Function to identify if an argument looks like a file path
        def looks_like_path(arg):
            return (arg.startswith('/') or arg.startswith('./') or 
                    arg.startswith('..') or ':' in arg or 'C:' in arg or 'D:' in arg)
        
        # Function to identify if an argument looks like a URL
        def looks_like_url(arg):
            return (arg.startswith('http') or 'youtube.com' in arg or 
                    'youtu.be' in arg or 'spotify.com' in arg)
        
        # Case 1: Download command
        if sys.argv[1] == 'download' and len(sys.argv) >= 3:
            # The download command expects: script.py download url output_path
            # Since arguments might have been split due to spaces, we need to reconstruct properly
            args = sys.argv[2:]  # Skip script name and 'download' command
            
            # Find the output path (should be the last argument that looks like a path)
            output_path = None
            url_end_idx = len(args)
            
            # Look for path from the end
            for i in range(len(args) - 1, -1, -1):
                if looks_like_path(args[i]):
                    output_path = args[i]
                    url_end_idx = i
                    break
            
            # If no path found, assume last argument is path (if there are enough arguments)
            if not output_path and len(args) >= 2:
                output_path = args[-1]
                url_end_idx = len(args) - 1
            
            # Reconstruct URL from remaining arguments
            url = ' '.join(args[:url_end_idx]) if url_end_idx > 0 else ""
            
            # Validate inputs
            if not url or not output_path:
                print(json.dumps({'success': False, 'error': 'URL and output path are required for download'}), file=sys.stderr)
                sys.exit(1)
            
            success = download_audio(url, output_path)
            if success:
                print(json.dumps({'success': True, 'message': 'Download completed successfully'}))
            else:
                print(json.dumps({'success': False, 'error': 'Download failed'}), file=sys.stderr)
                sys.exit(1)
                
        # Case 2: Search for track using metadata (3+ arguments)
        elif len(sys.argv) >= 3:
            args = sys.argv[1:]  # Skip script name
            
            # Check if any arguments look like file paths (downloads directory)
            path_idx = -1
            # Look for path argument (downloads directory)
            for i in range(len(args) - 1, -1, -1):
                if looks_like_path(args[i]):
                    path_idx = i
                    break
            
            if path_idx >= 0:
                # This is a search with downloads directory
                downloads_dir = args[path_idx]
                metadata_args = args[:path_idx]
                
                # Reconstruct track name and artist from metadata arguments
                if len(metadata_args) >= 2:
                    # For search queries, we want to preserve spaces in track and artist names
                    # Join all metadata args to form the full query
                    full_query = ' '.join(metadata_args)
                    
                    # Try to intelligently split into track and artist
                    # Look for common separators
                    separators = [' by ', ' - ', ' · ']  # Including the special character from Spotify
                    
                    track_name = full_query
                    artist_name = "Unknown Artist"
                    
                    # Try to find better separation
                    for sep in separators:
                        if sep in full_query:
                            parts = full_query.split(sep, 1)  # Split only on first occurrence
                            if len(parts) == 2:
                                track_name = parts[0].strip()
                                artist_name = parts[1].strip()
                                break
                            elif len(parts) > 2:
                                # Multiple occurrences, use first as track, rest as artist
                                track_name = parts[0].strip()
                                artist_name = sep.join(parts[1:]).strip()
                                break
                    
                    # If no separator found, use heuristics to split
                    if track_name == full_query:
                        # Simple heuristic: last word/phrase as artist, rest as track
                        words = full_query.split()
                        if len(words) > 1:
                            # Last word as artist, rest as track
                            artist_name = words[-1]
                            track_name = ' '.join(words[:-1])
                        else:
                            track_name = full_query
                            artist_name = "Unknown Artist"
                else:
                    track_name = metadata_args[0] if metadata_args else "Unknown"
                    artist_name = "Unknown Artist"
            else:
                # No downloads directory specified, treat all as metadata query
                metadata_args = args
                
                # Reconstruct track name and artist from metadata arguments
                if len(metadata_args) >= 2:
                    # Join all args to form the full query
                    full_query = ' '.join(metadata_args)
                    
                    # Try to intelligently split into track and artist
                    # Look for common separators
                    separators = [' by ', ' - ', ' · ']  # Including the special character from Spotify
                    
                    track_name = full_query
                    artist_name = "Unknown Artist"
                    
                    # Try to find better separation
                    for sep in separators:
                        if sep in full_query:
                            parts = full_query.split(sep, 1)  # Split only on first occurrence
                            if len(parts) == 2:
                                track_name = parts[0].strip()
                                artist_name = parts[1].strip()
                                break
                            elif len(parts) > 2:
                                # Multiple occurrences, use first as track, rest as artist
                                track_name = parts[0].strip()
                                artist_name = sep.join(parts[1:]).strip()
                                break
                    
                    # If no separator found, use heuristics to split
                    if track_name == full_query:
                        # Simple heuristic: last word/phrase as artist, rest as track
                        words = full_query.split()
                        if len(words) > 1:
                            # Last word as artist, rest as track
                            artist_name = words[-1]
                            track_name = ' '.join(words[:-1])
                        else:
                            track_name = full_query
                            artist_name = "Unknown Artist"
                else:
                    track_name = metadata_args[0] if metadata_args else "Unknown"
                    artist_name = "Unknown Artist"
            
            # Validate inputs
            if not track_name:
                print(json.dumps({'success': False, 'error': 'Track name is required'}), file=sys.stderr)
                sys.exit(1)
                
            result = search_and_extract_audio(track_name, artist_name)
            
            if result:
                print(json.dumps({
                    'success': True,
                    'title': result.get('title', ''),
                    'url': result.get('url', ''),
                    'duration': result.get('duration'),
                    'uploader': result.get('uploader', ''),
                    'webpage_url': result.get('webpage_url', ''),
                    'formats': result.get('formats', [])
                }))
            else:
                print(json.dumps({'success': False, 'error': 'Could not find audio'}), file=sys.stderr)
                sys.exit(1)
                
        # Case 3: Extract info from URL (single URL argument)
        elif len(sys.argv) == 2:
            # The URL might have been split due to spaces, so join all arguments
            url = sys.argv[1]
            
            # Validate URL
            if not url:
                print(json.dumps({'success': False, 'error': 'URL is required'}), file=sys.stderr)
                sys.exit(1)
            
            # Check if it's a Spotify URL
            if "spotify.com" in url or "open.spotify.com" in url or url.startswith("spotify:"):
                result = extract_spotify_url_info(url)
            else:
                # For other URLs, extract info directly
                result = extract_audio_info(url)
            
            if result:
                # Handle both single entries and search results
                if 'entries' in result and result['entries']:
                    entry = result['entries'][0]
                    print(json.dumps({
                        'success': True,
                        'title': entry.get('title', ''),
                        'url': entry.get('url', ''),
                        'duration': entry.get('duration'),
                        'uploader': entry.get('uploader', ''),
                        'webpage_url': entry.get('webpage_url', ''),
                        'formats': entry.get('formats', [])
                    }))
                else:
                    print(json.dumps({
                        'success': True,
                        'title': result.get('title', ''),
                        'url': result.get('url', ''),
                        'duration': result.get('duration'),
                        'uploader': result.get('uploader', ''),
                        'webpage_url': result.get('webpage_url', ''),
                        'formats': result.get('formats', [])
                    }))
            else:
                print(json.dumps({'success': False, 'error': 'Could not extract audio info'}), file=sys.stderr)
                sys.exit(1)
        else:
            print(json.dumps({'success': False, 'error': 'Invalid arguments'}), file=sys.stderr)
            sys.exit(1)
    except Exception as e:
        print(json.dumps({'success': False, 'error': f'Unexpected error: {str(e)}'}), file=sys.stderr)
        sys.exit(1)